#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output image
layout(rgba8, binding = 0) uniform writeonly image2D outputImage;

// 3D voxel texture
layout(binding = 1) uniform sampler3D voxelTexture;

// Camera and scene uniforms
layout(std140, binding = 2) uniform Camera {
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 invViewProjection;
    vec3 cameraPos;
    float time;
    vec2 resolution;
    vec2 padding;
};

uniform int voxelGridSize;
uniform vec3 sunPosition;

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 inverted;
};

// Generate a ray from screen coordinates
Ray getRay(vec2 uv) {
    // Convert to NDC
    vec4 nearPoint = vec4(uv * 2.0 - 1.0, -1.0, 1.0);
    vec4 farPoint = vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    
    // Transform to world space
    vec4 nearWorld = invViewProjection * nearPoint;
    vec4 farWorld = invViewProjection * farPoint;
    
    nearWorld /= nearWorld.w;
    farWorld /= farWorld.w;
    
    Ray ray;
    ray.origin = cameraPos;
    ray.direction = normalize(farWorld.xyz - nearWorld.xyz);
    ray.inverted = 1.0 / ray.direction;
    
    return ray;
}

// FIXED: Calculate ambient occlusion by sampling nearby voxels
// Now starts from the surface (offset by normal) instead of voxel center
float calculateAmbientOcclusion(ivec3 voxel, vec3 normal, vec3 gridSize, int samples) {
    float occlusion = 0.0;
    float radius = 3.0; // AO sampling radius
    
    // FIXED: Start sampling from the surface of the voxel, not its center
    // Offset by 0.5 * normal to position on the voxel face
    vec3 surfacePos = vec3(voxel) + 0.5 + normal * 0.5;
    
    // Generate sampling directions in a hemisphere around the normal
    for (int i = 0; i < samples; i++) {
        // Simple spiral sampling pattern
        float phi = float(i) * 2.399963; // Golden angle
        float cosTheta = 1.0 - (float(i) + 0.5) / float(samples);
        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
        
        vec3 sampleDir = vec3(
            cos(phi) * sinTheta,
            cosTheta,
            sin(phi) * sinTheta
        );
        
        // Orient to surface normal
        // Build tangent space
        vec3 up = abs(normal.y) < 0.999 ? vec3(0, 1, 0) : vec3(1, 0, 0);
        vec3 tangent = normalize(cross(up, normal));
        vec3 bitangent = cross(normal, tangent);
        
        sampleDir = normalize(
            tangent * sampleDir.x +
            normal * sampleDir.y +
            bitangent * sampleDir.z
        );
        
        // FIXED: Start at distance 0.6 to avoid sampling the current voxel
        // Sample at different distances
        for (float dist = 0.6; dist <= radius; dist += 0.8) {
            vec3 samplePos = surfacePos + sampleDir * dist;
            ivec3 sampleVoxel = ivec3(floor(samplePos));
            
            // Check if sample is within grid bounds
            if (all(greaterThanEqual(sampleVoxel, ivec3(0))) && 
                all(lessThan(sampleVoxel, ivec3(gridSize)))) {
                
                vec3 texCoord = (vec3(sampleVoxel) + 0.5) / gridSize;
                vec4 voxelData = texture(voxelTexture, texCoord);
                
                if (voxelData.a > 0.5) {
                    // Voxel is solid - contributes to occlusion
                    // Weight by distance (closer = more occlusion)
                    float weight = 1.0 - (dist / radius);
                    occlusion += weight;
                    break; // Stop sampling in this direction
                }
            }
        }
    }
    
    // FIXED: Simple normalization - divide by number of sample directions
    occlusion = occlusion / float(samples);
    
    // Return AO factor (1.0 = no occlusion, 0.0 = full occlusion)
    return 1.0 - clamp(occlusion, 0.0, 1.0);
}

// DDA voxel traversal algorithm
vec4 traceVoxelRay(Ray ray, vec3 gridSize) {
    // Transform ray to voxel space [0, gridSize]
    vec3 rayOrigin = ray.origin;
    vec3 rayDir = ray.direction;
    vec3 rayInv = ray.inverted;
    
    // Clamp origin to grid bounds
    vec3 minBound = vec3(0.0);
    vec3 maxBound = gridSize;
    
    // Ray-box intersection to find entry point
    vec3 t0 = (minBound - rayOrigin) * rayInv;
    vec3 t1 = (maxBound - rayOrigin) * rayInv;
    
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit = min(min(tmax.x, tmax.y), tmax.z);
    
    // Ray misses the grid
    if (tEnter > tExit || tExit < 0.0) {
        return vec4(0.0, 0.0, 0.0, 0.0);
    }
    
    // Start position (slightly inside the grid)
    tEnter = max(tEnter, 0.0);
    vec3 pos = rayOrigin + rayDir * (tEnter + 0.001);
    
    // Current voxel coordinate
    ivec3 voxel = ivec3(floor(pos));
    
    // Step direction (1 or -1 for each axis)
    ivec3 step = ivec3(sign(rayDir));
    
    // tDelta: how far along the ray we must move to cross a voxel boundary
    vec3 tDelta = abs(rayInv);
    
    // tMax: the t-value at which we cross the next voxel boundary
    vec3 voxelBoundary = vec3(voxel) + max(vec3(step), vec3(0.0));
    vec3 tMax = (voxelBoundary - rayOrigin) * rayInv;
    
    // Maximum number of steps to prevent infinite loops
    int maxSteps = int(gridSize.x + gridSize.y + gridSize.z);
    
    vec3 normal = vec3(0.0);
    
    for (int i = 0; i < maxSteps; i++) {
        // Check if current voxel is solid
        if (all(greaterThanEqual(voxel, ivec3(0))) && all(lessThan(voxel, ivec3(gridSize)))) {
            // Sample the 3D texture
            vec3 texCoord = (vec3(voxel) + 0.5) / gridSize;
            vec4 voxelData = texture(voxelTexture, texCoord);
            
            // If voxel is solid (alpha > 0)
            if (voxelData.a > 0.5) {
                // Calculate ambient occlusion
                // Adaptive AO based on distance
                float distToCamera = length(vec3(voxel) - cameraPos);
                int aoSamples = distToCamera < 40.0 ? 12 : (distToCamera < 80.0 ? 6 : 0);
                float ao = aoSamples > 0 ? (0.3 + 0.7 * calculateAmbientOcclusion(voxel, normal, gridSize, aoSamples)) : 1.0;
                
                // Simple lighting based on normal
                vec3 lightDir = normalize(sunPosition);
                float diffuse = max(dot(normal, lightDir), 0.0) * 0.7 + 0.3;
                
                // Apply AO to lighting
                float finalLight = diffuse * (0.3 + 0.7 * ao); // Blend AO with lighting
                
                return vec4(voxelData.rgb * finalLight, 1.0);
            }
        }
        
        // Step to next voxel
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x += tDelta.x;
                normal = vec3(-step.x, 0.0, 0.0);
            } else {
                voxel.z += step.z;
                tMax.z += tDelta.z;
                normal = vec3(0.0, 0.0, -step.z);
            }
        } else {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y += tDelta.y;
                normal = vec3(0.0, -step.y, 0.0);
            } else {
                voxel.z += step.z;
                tMax.z += tDelta.z;
                normal = vec3(0.0, 0.0, -step.z);
            }
        }
        
        // Exit if we're outside the grid
        if (any(lessThan(voxel, ivec3(0))) || any(greaterThanEqual(voxel, ivec3(gridSize)))) {
            break;
        }
    }
    
    // Sky/background color
    return vec4(0.5, 0.7, 1.0, 1.0);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixelCoord) / resolution;
    
    // Generate ray
    Ray ray = getRay(uv);
    
    // Voxel grid size (should match your 3D texture dimensions)
    vec3 gridSize = vec3(voxelGridSize, voxelGridSize, voxelGridSize);
    
    // Trace the ray
    vec4 color = traceVoxelRay(ray, gridSize);
    
    // Write to output image
    imageStore(outputImage, pixelCoord, color);
}
